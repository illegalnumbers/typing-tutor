    #include <QtGui>
    #include <QPalette>
    #include <QWidget>
    #include <QApplication>
    #include <QGraphicsScene>
    #include <QGraphicsView>
    #include <QGraphicsPixmapItem>
    #include "bacondemo.h"

BaconDemo::BaconDemo(QWidget *parent)
: QFrame(parent)
     {
        setFrameStyle(QFrame::Panel | QFrame::Sunken);
        setFocusPolicy(Qt::StrongFocus);
        isStarted = false;
        isPaused = false;
        clearBoard();

        nextPiece.setRandomShape();
    }

    QSize BaconDemo::sizeHint() const
    {
        return QSize(BoardWidth * 15 + frameWidth() * 2,
                     BoardHeight * 15 + frameWidth() * 2);
    }

    QSize BaconDemo::minimumSizeHint() const
    {
        return QSize(BoardWidth * 5 + frameWidth() * 2,
                     BoardHeight * 5 + frameWidth() * 2);
    }

    void BaconDemo::start()
    {
        if (isPaused)
            return;

        isStarted = true;
        isWaitingAfterLine = false;
        score = 0;
        level = 1;
        clearBoard();

        emit scoreChanged(score);
        emit levelChanged(level);

        newPiece();
        timer.start(timeoutTime(), this);
    }

    void BaconDemo::pause()
    {
        if (!isStarted)
            return;

        isPaused = !isPaused;
        if (isPaused) {
            timer.stop();
        } else {
            timer.start(timeoutTime(), this);
        }
        update();
    }

    void BaconDemo::paintEvent(QPaintEvent *)
    {
        QPainter painter(this);
        QRect rect = contentsRect();

        drawFrame(&painter);

        if (isPaused) {
            painter.drawText(rect, Qt::AlignCenter, tr("Pause"));
            return;
        }

        int boardTop = rect.bottom() - BoardHeight*squareHeight();

        for (int i = 0; i < BoardHeight; ++i) {
            for (int j = 0; j < BoardWidth; ++j) {
                TetrixShape shape = shapeAt(j, BoardHeight - i - 1);
                if (shape != NoShape)
                    drawSquare(painter, rect.left() + j * squareWidth(),
                               boardTop + i * squareHeight(), shape);
            }
        }

        if (curPiece.shape() != NoShape) {
            for (int i = 0; i < 9; ++i) {
                int x = curX + curPiece.x(i);
                int y = curY - curPiece.y(i);
                drawSquare(painter, rect.left() + x * squareWidth(),
                           boardTop + (BoardHeight - y - 1) * squareHeight(),
                           curPiece.shape());
            }
        }
    }

    void BaconDemo::keyPressEvent(QKeyEvent *event)
    {
        if (!isStarted || isPaused || curPiece.shape() == NoShape) {
            QWidget::keyPressEvent(event);
            return;
        }

        switch (event->key()) {
        case Qt::Key_Left:
            tryMove(curPiece, curX - 1, curY);
            break;
        case Qt::Key_Right:
            tryMove(curPiece, curX + 1, curY);
            break;
	case Qt::Key_2:
	    tryMove(curPiece.rotatedRight(), curX, curY);
	    break;
        case Qt::Key_Down:
	    oneLineDown();
            break;
        case Qt::Key_1:
            tryMove(curPiece.rotatedLeft(), curX, curY);
            break;
        case Qt::Key_Space:
	    //dropDown();
	    curPiece.setShape(NoShape);
            break;
        default:
            QWidget::keyPressEvent(event);
        }
    }

    void BaconDemo::timerEvent(QTimerEvent *event)
    {
        if (event->timerId() == timer.timerId()) {
            if (isWaitingAfterLine) {
                isWaitingAfterLine = false;
                newPiece();
                timer.start(timeoutTime(), this);
            } else {
                oneLineDown();
            }
        } else {
            QFrame::timerEvent(event);
        }
    }

    void BaconDemo::clearBoard()
    {
        for (int i = 0; i < BoardHeight * BoardWidth; ++i)
            board[i] = NoShape;
    }

    void BaconDemo::dropDown()
    {
        int dropHeight = 0;
        int newY = curY;
        while (newY > 0) {
            if (!tryMove(curPiece, curX, newY - 1))
                break;
            --newY;
            ++dropHeight;
        }
        pieceDropped(dropHeight);
    }

    void BaconDemo::oneLineDown()
    {
        if (!tryMove(curPiece, curX, curY - 1))
            pieceDropped(0);
    }

    void BaconDemo::pieceDropped(int dropHeight)
    {
        for (int i = 0; i < 9; ++i) {
            int x = curX + curPiece.x(i);
            int y = curY - curPiece.y(i);
            shapeAt(x, y) = curPiece.shape();
        }

        score += dropHeight + 7;
        emit scoreChanged(score);
        removeFullLines();

        if (!isWaitingAfterLine)
            newPiece();
    }

    void BaconDemo::removeFullLines()
    {
        int numFullLines = 0;

        for (int i = BoardHeight - 1; i >= 0; --i) {
            bool lineIsFull = true;

            for (int j = 0; j < BoardWidth; ++j) {
                if (shapeAt(j, i) == NoShape) {
                    lineIsFull = false;
                    break;
                }
            }

            if (lineIsFull) {
                ++numFullLines;
                for (int k = i; k < BoardHeight - 1; ++k) {
                    for (int j = 0; j < BoardWidth; ++j)
                        shapeAt(j, k) = shapeAt(j, k + 1);
                }
                for (int j = 0; j < BoardWidth; ++j)
                    shapeAt(j, BoardHeight - 1) = NoShape;
            }
        }

        if (numFullLines > 0) {
            score += 10 * numFullLines;
            emit scoreChanged(score);

            timer.start(500, this);
            isWaitingAfterLine = true;
            curPiece.setShape(NoShape);
            update();
        }
    }

    void BaconDemo::newPiece()
    {
      //    srand(time(NULL));
	//     random = rand() % 26;
	//	char randChar = alphabet[random];
        curPiece = nextPiece;
        curX = BoardWidth / 2 + 1;
        curY = BoardHeight - 1 + curPiece.minY();

        if (!tryMove(curPiece, curX, curY)) {
            curPiece.setShape(NoShape);
            timer.stop();
            isStarted = false;
        }
    }

    bool BaconDemo::tryMove(const TetrixPiece &newPiece, int newX, int newY)
    {
        for (int i = 0; i < 9; ++i) {
            int x = newX + newPiece.x(i);
            int y = newY - newPiece.y(i);
            if (x < 0 || x >= BoardWidth || y < 0 || y >= BoardHeight)
                return false;
            if (shapeAt(x, y) != NoShape)
                return false;
        }

        curPiece = newPiece;
        curX = newX;
        curY = newY;
        update();
        return true;
    }

    void BaconDemo::drawSquare(QPainter &painter, int x, int y, TetrixShape shape)
    {
        static const QRgb colorTable[14] = {
            0x000000, 0xCC6666, 0x66CC66, 0x6666CC,
            0xCCCC66, 0xCC66CC, 0x66CCCC, 0xDAAA00,
	    0x000088, 0xCCCC00, 0x333333, 0xFF00FF,
	    0xFF9933, 0xCCCCCC
        };

        QColor color = colorTable[int(shape)];
        painter.fillRect(x + 1, y + 1, squareWidth() - 2, squareHeight() - 2,
                         color);

        painter.setPen(color.light());
        painter.drawLine(x, y + squareHeight() - 1, x, y);
        painter.drawLine(x, y, x + squareWidth() - 1, y);

        painter.setPen(color.dark());
        painter.drawLine(x + 1, y + squareHeight() - 1,
                         x + squareWidth() - 1, y + squareHeight() - 1);
        painter.drawLine(x + squareWidth() - 1, y + squareHeight() - 1,
                         x + squareWidth() - 1, y + 1);
    }
